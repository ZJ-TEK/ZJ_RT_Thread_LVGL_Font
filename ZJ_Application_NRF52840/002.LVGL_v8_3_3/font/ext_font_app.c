/**
 * This file is generated by py_FontMaker generation tools
 * you can porting your external storage
 *
 * author: John
 * github: https://github.com/ZJ-TEK/Py_FontMaker_Beta.git
 */
#include "ext_font_app.h"
#include "ext_font_engine.h"

/*Add the external storage driver header file*/

/*******************************************************************************************************
 *         Please include your header file and replace it with your print function
*******************************************************************************************************/
#include "bsp_qspi_dri.h"
#include <rtthread.h>
#include "nrf_log.h"
#define LOG_TAG     "font_app"
#define LOG_E       NRF_LOG_INFO
#define LOG_W       NRF_LOG_INFO
#define LOG_I       NRF_LOG_INFO
#define LOG_D       NRF_LOG_INFO
/*******************************************************************************************************/

/* Define your font 
 * eg: public_font_t HarmonyOS_24_2BPP
 */
public_font_t HarmonyOS_Sans_SC_Medium_24_2Bpp;
public_font_t Full_HarmonyOS_Sans_SC_Medium_24_2Bpp;
public_font_t icon_font_32_8Bpp;
public_font_t emoji_font_32_8Bpp;


/* Define your font type table
 * eg: &HarmonyOS_24_2BPP
 */
const public_font_t *font_type_tbale[]={
    &HarmonyOS_Sans_SC_Medium_24_2Bpp,
    &Full_HarmonyOS_Sans_SC_Medium_24_2Bpp,
    &icon_font_32_8Bpp,
    &emoji_font_32_8Bpp,
    &fake_font,
    &INNER_HarmonyOS_Sans_SC_Medium_24_2bpp,
};


static uint32_t font_get_data(uint32_t offset, uint8_t *pbuf, uint32_t size)
{
/*******************************************************************************************************
 *             Please implement your read operation interface
 *******************************************************************************************************/
    #define EXT_FONT_FLASH_START_ADDR 0x00
    uint32_t read_size = 0;
    uint32_t err_code = bsp_qspi_flash_read(pbuf, size + 3, EXT_FONT_FLASH_START_ADDR + offset);
    //if err_code == SUCCESS)
    {
        read_size = size;
    }
/*******************************************************************************************************/

    return read_size;
}

bool app_font_init(void)
{
    uint32_t res = 0;
/* creat your font library
 * eg: res += ext_font_create(e_HarmonyOS_24_2BPP, &HarmonyOS_24_2BPP, &HarmonyOS_24_2BPP_font_info,font_get_data);
 */
    res += ext_font_create(HARMONYOS_SANS_SC_MEDIUM_24_2BPP, &HarmonyOS_Sans_SC_Medium_24_2Bpp, &HarmonyOS_Sans_SC_Medium_24_2Bpp_font_info, font_get_data);
    res += ext_font_create(FULL_HARMONYOS_SANS_SC_MEDIUM_24_2BPP, &Full_HarmonyOS_Sans_SC_Medium_24_2Bpp, &Full_HarmonyOS_Sans_SC_Medium_24_2Bpp_font_info, font_get_data);
    res += ext_font_create(ICON_FONT_32_8BPP, &icon_font_32_8Bpp, &icon_font_32_8Bpp_font_info, font_get_data);
    res += ext_font_create(EMOJI_FONT_32_8BPP, &emoji_font_32_8Bpp, &emoji_font_32_8Bpp_font_info, font_get_data);
    if(res != 0)
    {
        return false;
    }

    return true;
}

FONT_TYPE app_get_font_type(const public_font_t *pFont)
{
    FONT_TYPE font_type;
    for (font_type = (FONT_TYPE)0; font_type < FONT_TYPE_MAX; font_type ++)
    {
        if (pFont == font_type_tbale[font_type])
        {
            return font_type;
        }
    }
    return FONT_TYPE_MAX;
}

public_font_t *app_get_font(FONT_TYPE font_type)
{
    if (font_type < FONT_TYPE_MAX)
    {
        return (public_font_t*)font_type_tbale[font_type];
    }
    else
    {
        return NULL;
    }
}

void *app_get_fake_font(void)
{
    return (void *)font_type_tbale[FAKE_FONT];
}

#if ICON_FONT_ENABLE
void *app_get_icon_font(void)
{
    return (void *)font_type_tbale[ICON_FONT_32_8BPP];
}
#endif


#if EMOJI_FONT_ENABLE
void *app_get_emoji_font(void)
{
    return (void *)font_type_tbale[EMOJI_FONT_32_8BPP];
}
#endif

