/**
 * This file is generated by py_FontMaker generation tools
 * Please DO NOT modify this file
 *
 * author: John
 * github: https://github.com/ZJ-TEK/Py_FontMaker_Beta.git
 */
#include "ext_font_engine.h"
#include "ext_font_app.h"

/*******************************************************************************************************
 *         Please include your header file and replace it with your print function
*******************************************************************************************************/
#include <rtthread.h>
#include "nrf_log.h"
#define LOG_TAG     "font_engine"
#define LOG_E       NRF_LOG_INFO
#define LOG_W       NRF_LOG_INFO
#define LOG_I       NRF_LOG_INFO
#define LOG_D       NRF_LOG_INFO
/*******************************************************************************************************/

#if (BITMAP_RLE_ENCODE_ENABLE == 1 && BITMAP_RLE_ENCODE_BUFFER_USE_MALLOC == 0)
uint8_t glyph_bitmap_buf[2][MAX_STATIC_BITMAP_BUF_SIZE];    // !!! Using RLE will use more memory
#else
uint8_t glyph_bitmap_buf[MAX_STATIC_BITMAP_BUF_SIZE];       // !!! Note memory security
#endif


#pragma pack(1)
#define FONT_LIB_NAME_LEN  8
typedef struct
{
    uint8_t  fl_magic[FONT_LIB_NAME_LEN];
    uint32_t fl_version;
    uint32_t fl_font_type_num;
    uint32_t fl_first_font_offset;
} font_lib_head_t;

#pragma pack()

typedef struct
{
    font_type_info_t            *font_type_info;          // Information about each font type
    pfunc_get_data              p_get_data_func;          // Access to the data of the interface, the user needs to implement
    uint32_t                    last_unicode_cache;       // Last character in the cache
    cmap_sparse_table_t         *last_sparse_cmap_cache;  // Cache the last character position information(has Codepoint)
    cmap_continous_table_t      *last_cmap_cache;         // Cache the last character position information(no Codepoint)
} font_user_data_t;


typedef struct
{
    font_lib_head_t *fl_head;
    bool            fl_inited;           // Font initialization flag
    bool            fl_version_ok;       // Whether the font version is correct, the version error will use fake font
} font_lib_info_t;


#if(EXT_FONT_DSC_CACHE_ENABLE)
typedef struct
{
    uint32_t            unicode;
    FONT_TYPE           font_type;
    glyph_dsc_t         font_describe;
} ext_font_cache_t;
#endif


/*******************************************************************************************************/
// Private variables
static font_lib_info_t  font_lib_info = {NULL, false, false};
static font_user_data_t font_user_data[FONT_TYPE_MAX];
static font_lib_head_t  font_lib_head;


#if(EXT_FONT_DSC_CACHE_ENABLE)
static ext_font_cache_t    font_cache[EXT_FONT_DSC_CACHE_CNT];
static uint32_t            cur_cache_index = 0;
#endif

/*******************************************************************************************************/
// Private functions
static bool __font_lib_init(font_lib_info_t *p_font_lib, uint32_t fl_version, uint32_t fl_addr, pfunc_get_data p_get_data_func);


#if !CMAP_HASH_ENABLE
int binary_method_search(const cmap_sparse_table_t *p_cmap_table, uint16_t cmap_size, uint32_t unicode)
{
    uint16_t mid = 0;
    uint16_t min = 0;
    uint16_t max = cmap_size - 1;

    while(min <= max)
    {
        mid = (max + min) / 2;
        if(p_cmap_table[mid].code_point > unicode)
        {
            max = mid - 1;
        }
        else if(p_cmap_table[mid].code_point < unicode)
        {
            min = mid + 1;
        }
        else
        {
            return mid;
        }
    }

    return -1;
}
#else
static uint16_t hash_func(uint32_t key, uint16_t size)
{
    return key % size;
}

static uint16_t re_hash(uint32_t old_hash, uint16_t size)
{
    return (old_hash + 1) % size;
}

int hash_unicode_get_index(const cmap_sparse_table_t *p_cmap_hash_table, uint16_t cmap_size, uint32_t unicode)
{
    uint16_t start_slot = hash_func(unicode, cmap_size);  // get hash start_slot
    uint16_t position   = start_slot;
    while (p_cmap_hash_table[position].code_point != 0)
    {
       // No empty slot is found, no target is found, and the loop continues without ending
        if (p_cmap_hash_table[position].code_point == unicode)
        {
            return position; //Find the target
        }
        else
        {
            position = re_hash(position, cmap_size);  // Keep looking
            if (position == start_slot)
            {
                // That means they looked around, didn't find it, that means there's no target
                return -1;
            }
        }
    }

     return -1;
}
#endif


#if BITMAP_RLE_ENCODE_ENABLE
int RLE_glyph_bitmap_decode(uint8_t *inbuf,uint16_t in_size, uint8_t *outbuf,uint16_t out_size)
{
    uint8_t *src         = inbuf;
    uint16_t i           = 0;
    uint16_t decode_size = 0;
    uint8_t count        = 0;
    uint8_t sign         = 0;
    while(src < (inbuf + in_size))
    {
        sign = *src++;
        count = sign & 0x7F;
        if((decode_size + count) > out_size)
        {
            return -1;
        }
        if((sign & 0x80) == 0x80)
        {
            for(i = 0; i < count; i++)
            {
                outbuf[decode_size++] = *src;
            }
            src ++;
        }
        else
        {
            for(i = 0; i < count; i++)
            {
                outbuf[decode_size++] = *src++;
            }
        }
    }
    return decode_size;
}
#endif


static cmap_sparse_table_t *__get_cmap_by_unicode(const public_font_t *pFont, uint32_t unicode)
{
    font_user_data_t *p_font_user_data         = ( font_user_data_t *)pFont->user_data;
    font_type_info_t *p_font_info              = NULL;
    uint32_t offset                            = 0;
    uint16_t code_delta                        = 0;
    static cmap_sparse_table_t cache_cmap_info = {0};
    cmap_continous_table_t cmap_info;

    if(pFont == NULL || p_font_user_data == NULL)
    {
        LOG_E("pFont ro p_font_user_data is NULL");
        return NULL;
    }

    // the unicode has cache
    if(p_font_user_data->last_unicode_cache == unicode)
    {
        return p_font_user_data->last_sparse_cmap_cache;
    }

    p_font_info = p_font_user_data->font_type_info;

    if(p_font_info == NULL
       || unicode > p_font_info->last_code
       || unicode < p_font_info->first_code
       || p_font_user_data->p_get_data_func == NULL
       || p_font_info->code_num == 0)
    {
        LOG_E("parameter error or NULL");
        return NULL;
    }

    if(p_font_info->p_cmap_table == NULL)
    {
        /* Full character library,continuity of cmap table, the offset can be calculated directly */
        // case 1: cmap in the external storage
        if(p_font_info->cmap_continued == 1)
        {
            code_delta = unicode - p_font_info->first_code;
            offset = sizeof(cmap_continous_table_t) * code_delta;
            offset += p_font_info->cmap_offset;
            if(p_font_user_data->p_get_data_func != NULL)
            {
                if(sizeof(cmap_continous_table_t) == (*p_font_user_data->p_get_data_func)(offset, (uint8_t *)&cmap_info, sizeof(cmap_continous_table_t)))
                {
                    cache_cmap_info.code_point = unicode;
                    cache_cmap_info.offset = cmap_info.offset;
                    cache_cmap_info.size = cmap_info.size;
                    // Got cmap. Cache it
                    p_font_user_data->last_unicode_cache = unicode;
                    p_font_user_data->last_sparse_cmap_cache = &cache_cmap_info;
                    return p_font_user_data->last_sparse_cmap_cache;
                }
            }
        }
    }
    else //part of character library 
    {
        // case 2: cmap in the XIP and continous
        if(p_font_info->cmap_continued == 1)
        {
            code_delta = unicode - p_font_info->first_code;
            if(code_delta < p_font_info->code_num)
            {
                 // Got cmap. Cache it
                p_font_user_data->last_unicode_cache     = unicode;
                p_font_user_data->last_sparse_cmap_cache = &(p_font_info->p_cmap_table[code_delta]);
                return p_font_user_data->last_sparse_cmap_cache;
            }
        }
        else
        {
            // case 3: cmap in the XIP but not continous
#if !CMAP_HASH_ENABLE
            // binary method search cmap table
            int16_t finded = binary_method_search(p_font_info->p_cmap_table, p_font_info->code_num, unicode);
#else
            int16_t finded = hash_unicode_get_index(p_font_info->p_cmap_table, p_font_info->code_num, unicode);
#endif
            if(finded != -1)
            {
                 // Got cmap. Cache it
                p_font_user_data->last_unicode_cache     = unicode;
                p_font_user_data->last_sparse_cmap_cache = &(p_font_info->p_cmap_table[finded]);
                return p_font_user_data->last_sparse_cmap_cache;
            }
        }
    }

    return NULL;
}


static const uint8_t *__user_font_get_bitmap(const public_font_t *pFont, uint32_t unicode)
{
    font_user_data_t *p_font_user_data = (font_user_data_t *)pFont->user_data;
    uint32_t bitmap_offset = 0;
    uint32_t glyph_data_size = 0;
    cmap_sparse_table_t *p_cmap_sparse_table = NULL;
    font_type_info_t *p_font_info = NULL;

    if(pFont == NULL || p_font_user_data == NULL)
    {
        LOG_E("pFont or p_font_user_data is NULL");
        return NULL;
    }

    // Discard special characters
    if(unicode < 0x20)
    {
        // LOG_E("unicode special ignore");
        return NULL;
    }

    if(pFont->get_glyph_bitmap == fake_font.get_glyph_bitmap)
    {
        // When there are no characters in the font, use fake font
        return fake_font.get_glyph_bitmap(&fake_font, unicode);
    }

    p_font_info = p_font_user_data->font_type_info;

    if(p_font_info == NULL)
    {
        LOG_E("p_font_info is NULL");
        return NULL;
    }

    if(p_font_user_data->p_get_data_func == NULL)
    {
        LOG_E("p_font_user_data->p_get_data_func is NULL");
        return NULL;
    }

    if(unicode > p_font_info->last_code || unicode < p_font_info->first_code)
    {
        // When there are no characters in the font, use fake font
        return fake_font.get_glyph_bitmap(&fake_font, unicode);
    }

    p_cmap_sparse_table = __get_cmap_by_unicode(pFont, unicode);

    if(p_cmap_sparse_table == NULL)
    {
        // When there are no characters in the font, use fake font
        return fake_font.get_glyph_bitmap(&fake_font, unicode);
    }

    bitmap_offset = p_cmap_sparse_table->offset;

    if((p_cmap_sparse_table->size) == 0)
    {
        // When there are no characters in the font, use fake font
        return fake_font.get_glyph_bitmap(&fake_font, unicode);
    }

    // get bitmap
    glyph_data_size = (p_cmap_sparse_table->size) - sizeof(char_bitmap_attribute_t);

    // Preventing Data Overflow
    if(glyph_data_size > MAX_STATIC_BITMAP_BUF_SIZE)
    {
        LOG_E("glyph_data_size too big");
        return NULL;
    }

#if BITMAP_RLE_ENCODE_ENABLE
#if BITMAP_RLE_ENCODE_BUFFER_USE_MALLOC
    uint8_t *p_buf_temp = FONT_MALLOC(glyph_data_size);
    if(!p_buf_temp)
    {
        LOG_E("FONT_MALLOC failed size= %d", glyph_data_size);
        return NULL;
    }
    if(glyph_data_size != (*(p_font_user_data->p_get_data_func))(bitmap_offset + sizeof(char_bitmap_attribute_t), p_buf_temp, glyph_data_size))
    {
        FONT_FREE(p_buf_temp);
        LOG_E("glyph data get failed");
        return NULL;
    }

    if(RLE_glyph_bitmap_decode(p_buf_temp, glyph_data_size, &glyph_bitmap_buf[0], MAX_STATIC_BITMAP_BUF_SIZE) == -1)
    {
        FONT_FREE(p_buf_temp);
        LOG_E("RLE decode failed");
        return NULL;
    }
    FONT_FREE(p_buf_temp);
    return &glyph_bitmap_buf[0];
#else
    if(glyph_data_size != (*(p_font_user_data->p_get_data_func))(bitmap_offset + sizeof(char_bitmap_attribute_t), &glyph_bitmap_buf[0][0], glyph_data_size))
    {
        LOG_E("glyph data get failed");
        return NULL;
    }

    if(RLE_glyph_bitmap_decode(&glyph_bitmap_buf[0][0], glyph_data_size, &glyph_bitmap_buf[1][0], MAX_STATIC_BITMAP_BUF_SIZE) == -1)
    {
        LOG_E("RLE decode failed");
        return NULL;
    }
    return &glyph_bitmap_buf[1][0];
#endif
#else
    if(glyph_data_size != (*(p_font_user_data->p_get_data_func))(bitmap_offset + sizeof(char_bitmap_attribute_t), &glyph_bitmap_buf[0], glyph_data_size))
    {
        LOG_E("glyph data get failed");
        return NULL;
    }

    return &glyph_bitmap_buf[0];
#endif
}


static bool __user_font_get_glyph_dsc(const public_font_t *pFont, glyph_dsc_t *p_bitmap_dsc, uint32_t unicode, uint32_t unicode_letter_next)
{
    font_user_data_t *p_font_user_data = NULL;
    uint32_t glyph_dsc_offset = 0;
    uint16_t glyph_data_size = 0;
    char_bitmap_attribute_t bitmap_dsc = { 0 };
    cmap_sparse_table_t *p_cmap_sparse_table = NULL;
    font_type_info_t *p_font_info = NULL;

    if(pFont == NULL)
    {
        LOG_E("pFont is NULL");
        return false;
    }

    // Discard special characters
    if(unicode < 0x20)
    {
        // LOG_E("unicode special ignore");
        return false;
    }

    if(pFont->get_glyph_dsc == fake_font.get_glyph_dsc)
    {
        // When there are no characters in the font, use fake font
        return fake_font.get_glyph_dsc(&fake_font, p_bitmap_dsc, unicode, unicode_letter_next);
    }

#if(EXT_FONT_DSC_CACHE_ENABLE)
    FONT_TYPE FontTypeTemp;
    FontTypeTemp = app_get_font_type(pFont);
    for(int i = 0; i < EXT_FONT_DSC_CACHE_CNT; i++)
    {
        if((unicode == font_cache[i].unicode) && (FontTypeTemp==font_cache[i].font_type))
        {
            memcpy(p_bitmap_dsc, &font_cache[i].font_describe, sizeof(glyph_dsc_t));
            return true;
        }
    }
#endif

    p_font_user_data = (font_user_data_t *)pFont->user_data;

    if(p_font_user_data == NULL)
    {
        LOG_E("p_font_user_data is NULL");
        return false;
    }

    p_font_info = p_font_user_data->font_type_info;

    if(p_font_info == NULL)
    {
        LOG_E("p_font_info is NULL");
        return false;
    }

    if(p_font_user_data->p_get_data_func == NULL)
    {
        LOG_E("p_font_user_data->p_get_data_func is NULL");
        return false;
    }

    if(unicode_letter_next < 0xFFFFFFFF && (unicode > p_font_info->last_code || unicode < p_font_info->first_code))
    {
        // When there are no characters in the font, use fake font
        return fake_font.get_glyph_dsc(&fake_font, p_bitmap_dsc, unicode, unicode_letter_next);
    }

    p_cmap_sparse_table = __get_cmap_by_unicode(pFont, unicode);

    if(unicode_letter_next < 0xFFFFFFFF && p_cmap_sparse_table == NULL)
    {
        // When there are no characters in the font, use fake font
        return fake_font.get_glyph_dsc(&fake_font, p_bitmap_dsc, unicode, unicode_letter_next);
    }
	else if (p_cmap_sparse_table == NULL)
	{
        return false;
    }

    glyph_dsc_offset = p_cmap_sparse_table->offset;

    if(unicode_letter_next < 0xFFFFFFFF && glyph_dsc_offset == 0)
    {
        // When there are no characters in the font, use fake font
        return fake_font.get_glyph_dsc(&fake_font, p_bitmap_dsc, unicode, unicode_letter_next);
    }

    // get bitmap description
    glyph_data_size = sizeof(char_bitmap_attribute_t);
    if(glyph_data_size != (*(p_font_user_data->p_get_data_func))(glyph_dsc_offset, (uint8_t *)&bitmap_dsc, glyph_data_size))
    {
        return false;
    }

    memset(p_bitmap_dsc, 0, sizeof(glyph_dsc_t));
    p_bitmap_dsc->bpp   = p_font_info->bpp;
    p_bitmap_dsc->adv_w = bitmap_dsc.x_advance;
    p_bitmap_dsc->box_w = bitmap_dsc.bytes_pre_line * 8 / p_bitmap_dsc->bpp;
    p_bitmap_dsc->box_h = bitmap_dsc.y_size;
    p_bitmap_dsc->ofs_x = bitmap_dsc.x_off;
#if LVGL_FONT_ENABLE
    p_bitmap_dsc->ofs_y = pFont->line_height
                          - bitmap_dsc.y_off + 1
                          - bitmap_dsc.y_size
                          - pFont->base_line;
#else
    p_bitmap_dsc->ofs_y = bitmap_dsc.y_off;
#endif

#if(EXT_FONT_DSC_CACHE_ENABLE)
    FONT_TYPE Enum_FontType = app_get_font_type(pFont);
    if (Enum_FontType != FONT_TYPE_MAX)
    {
        font_cache[cur_cache_index].font_type = Enum_FontType;
        font_cache[cur_cache_index].unicode = unicode;
        memcpy(&font_cache[cur_cache_index].font_describe, p_bitmap_dsc, sizeof(glyph_dsc_t));

        cur_cache_index++;
        cur_cache_index %= EXT_FONT_DSC_CACHE_CNT;
    }
#endif

    return true;
}

int ext_font_create(FONT_TYPE font_type, public_font_t *pFont, const font_type_info_t *p_font_info, pfunc_get_data p_get_data_func)
{
    font_user_data_t *p_font_user_data = NULL;

    p_font_user_data = &font_user_data[font_type];
    memset(p_font_user_data, 0, sizeof(font_user_data_t));

    // Get font info. For example, font's height, bpp etc.
    if(p_get_data_func == NULL)
    {
        LOG_E("p_get_data_func invalidate\n");
        goto ERROR;
    }

    // Font lib init
    if(!__font_lib_init(&font_lib_info, FONT_LIB_MAGIC, 0,  p_get_data_func))
    {
        goto ERROR;
    }

    // Init userdata
    p_font_user_data->p_get_data_func = p_get_data_func;
    p_font_user_data->font_type_info = (font_type_info_t *)p_font_info;

#if LVGL_FONT_ENABLE
    pFont->base_line        = p_font_info->y_dist - p_font_info->baseline + 1;
#else
    pFont->base_line        = p_font_info->baseline;
#endif
    pFont->line_height      = p_font_info->y_dist;
    pFont->get_glyph_bitmap = __user_font_get_bitmap;
    pFont->get_glyph_dsc    = __user_font_get_glyph_dsc;
    pFont->user_data        = p_font_user_data;

    return 0;

ERROR:
    // When there are no characters in the font, use fake font
    memcpy(pFont, &fake_font, sizeof(public_font_t));

    return -1;
}

// Init Font lib
static bool __font_lib_init(font_lib_info_t *p_font_lib, uint32_t fl_version, uint32_t fl_addr, pfunc_get_data p_get_data_func)
{
    uint32_t lib_head_size = 0;

    if(p_font_lib == NULL)
    {
        return false;
    }

    if(p_font_lib->fl_inited)
    {
        LOG_I("Font lib initialed, NO need to init anymore\n");
        return true;
    }

    if(p_font_lib->fl_head == NULL)
    {
        p_font_lib->fl_head = &font_lib_head;
    }

    // Get font lib infomation
    if(p_get_data_func == NULL)
    {
        LOG_E("p_get_data_func invalidate\n");
        goto ERROR;
    }

    lib_head_size = sizeof(font_lib_head_t);
    if(lib_head_size != (*(p_get_data_func))(fl_addr, (uint8_t*)p_font_lib->fl_head, lib_head_size))
    {
        LOG_E("Read data error\n");
        goto ERROR;
    }

    // Check font lib infomation
    // 1. Check magic
    if(p_font_lib->fl_head->fl_magic[0] != 'J'
       || p_font_lib->fl_head->fl_magic[1] != 'o'
       || p_font_lib->fl_head->fl_magic[2] != 'h'
       || p_font_lib->fl_head->fl_magic[3] != 'n'
       || p_font_lib->fl_head->fl_magic[4] != '_'
       || p_font_lib->fl_head->fl_magic[5] != 'L'
       || p_font_lib->fl_head->fl_magic[6] != 'I'
       || p_font_lib->fl_head->fl_magic[7] != 'B')
    {
        LOG_E("Invalidate font file\n");
        goto ERROR;
    }

    // 2. Check Version
    if(p_font_lib->fl_head->fl_version == fl_version)
    {
        p_font_lib->fl_version_ok = true;
    }
    else
    {
        LOG_I("!!!Font lib version error\n");
        p_font_lib->fl_version_ok = false;
        goto ERROR;
    }

    LOG_I("Font lib init success\n");
    p_font_lib->fl_inited = true;
    return true;

ERROR:
    if(p_font_lib->fl_head != NULL)
    {
        p_font_lib->fl_head = NULL;
    }
    return false;
}

bool app_font_version_ok(void)
{
    LOG_I("FONT_LIB_MAGIC = %x, FONT_LIB_VERSION = %s",FONT_LIB_MAGIC, FONT_LIB_VERSION);
    return font_lib_info.fl_version_ok;
}


